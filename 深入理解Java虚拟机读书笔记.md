## 2 运行时数据区域 ##

问：栈为什么会出现溢出？

这里栈指的是Java方法调用的虚拟机栈，一个应用程序分配的最大内存是固定的，当Java堆、Java方法区、本地方法栈分别占用一定内存后，剩下的是虚拟机栈所使用空间，这里不包括native库自己`new``malloc`申请的内存。一个线程对应一个Java栈。栈空间随着线程内使用的方法变多或者局部变量变多而随着变大，但有最大值，当需要超过最大值时，抛出`StackOverflowError`，所以栈溢出有几种可能性：
	* Java方法调用方法数过多（递归忘记终止条件）
	* Java一个方法的栈帧内申请了过多局部变量
	* 每个线程创建申请的线程数过多，

问：ART虚拟机不同于Java虚拟机基于栈指令集是什么意思？
答：ART虚拟机基于寄存器是把Java虚拟机栈帧中的操作数栈用寄存器代替，基于栈的指令集和基于寄存器的指令集各有优势，基于栈优点是可移植，而寄存器不可避免的受硬件约束，但栈架构指令集缺点就是执行速度慢，内存始终是计算机执行速度的瓶颈。

问：虚拟机哪些内存区域是线程独有的，哪些是共享的？
答：程序计数器、虚拟机栈、本地方法栈是线程独有的，Java堆、方法区（运行时产量池）是线程共享的

* `final`修饰的变量、`String str = "abcdef"`都存放在方法区的常量区
* `String.intern()`方法判断调用者是否在常量区，如果不在，则copy一份到常量区，并返回常量区的地址。
* Java栈帧中存放：局部变量（原始类型）、Reference类型（记录数据存放的堆地址）、返回值、内部方法操作符
* 方法内申请的数组内容存放在堆中，例如`int[] arr={1,2,3,4}`
* 程序运行时每个方法的栈帧大小是编译时就确定的，但方法内`new`的对象的大小是运行时才知道

## 3 垃圾收集器和内存分配策略 ##

* GC算法一般采用可达性分析（Reachability Analysis）算法，从`GC Roots`开始向下搜索，如果对象不可达，则回收对象，`GC Roots`对象包括下面几种：
	1. 虚拟机栈（栈帧中本地变量表）中引用的对象
	2. 方法区中类静态属性引用的对象
	3. 方法区中常量引用的对象
	4. 本地方法栈中native层引用的对象

## 6 class类文件的结构 ##

问：为什么内部类可以访问外部类的成员变量？
答：Java编译内部类时，会给内部类对象内部添加一个成员字段，这个字段引用外部类对象（这也是为什么先有外部类对象，才有内部类对象），这个编译器新增的字段会随着类成员其他字段一起写入class文件的类字段表中。

问：想想native代码如何访问Java代码？
答：只能通过反射，访问class文件，通过class结构规定的字符串查找class文件中的类表和方法表。

* Java语言中类中的方法可以重载，但字段不能重载

## 12 Java内存模型和线程

**volatile能保证数据的可见性，但不能保证操作的原子性，volatile还能通过内存屏障避免指令重排，保证有序性**

* 悲观锁（互斥锁，临界区、信号量）因为会从进入阻塞状态，从用户态转到内核态，性能消耗比较大
* 乐观锁（自旋锁）通过一个flag的标记位来记录是否能进入同步状态，如果不能，则循环检查，性能消耗小

*问：自旋锁的标志位判断怎么能保证线程安全呢？*

答：标志位通过CPU指令集：CAS指令（Compare And Swap）来保证标识的原子更换操作，Java的`AtomicInteger`也是通过CAS指令实现的原子性